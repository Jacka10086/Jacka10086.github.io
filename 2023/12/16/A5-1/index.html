<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>A5-1 | Jacka10086's Blog</title><meta name="author" content="Jacka10086"><meta name="copyright" content="Jacka10086"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="COM410 编程实践（COM410 Programming in Practice）A5.1 栈（A5.1 Stacks）栈的日常应用（Daily Applications of Stacks） 在日常生活中，栈是一种常见的数据结构，例如书堆、盘子堆、礼物堆等。 当你从栈中移除一个项目时，你总是取走位于顶部的那个。 栈顶的项目是最后被添加进去的。  栈的特点（Characteristics of">
<meta property="og:type" content="article">
<meta property="og:title" content="A5-1">
<meta property="og:url" content="http://example.com/2023/12/16/A5-1/index.html">
<meta property="og:site_name" content="Jacka10086&#39;s Blog">
<meta property="og:description" content="COM410 编程实践（COM410 Programming in Practice）A5.1 栈（A5.1 Stacks）栈的日常应用（Daily Applications of Stacks） 在日常生活中，栈是一种常见的数据结构，例如书堆、盘子堆、礼物堆等。 当你从栈中移除一个项目时，你总是取走位于顶部的那个。 栈顶的项目是最后被添加进去的。  栈的特点（Characteristics of">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2023/10/18/fq6OmvaUIxkbdo5.jpg">
<meta property="article:published_time" content="2023-12-16T05:17:27.000Z">
<meta property="article:modified_time" content="2023-12-16T05:38:38.653Z">
<meta property="article:author" content="Jacka10086">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/10/18/fq6OmvaUIxkbdo5.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/12/16/A5-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'A5-1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-16 05:38:38'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/10/18/fq6OmvaUIxkbdo5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">112</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Jacka10086's Blog"><span class="site-name">Jacka10086's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">A5-1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-12-16T05:17:27.000Z" title="Created 2023-12-16 05:17:27">2023-12-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-12-16T05:38:38.653Z" title="Updated 2023-12-16 05:38:38">2023-12-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="A5-1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="COM410-编程实践（COM410-Programming-in-Practice）"><a href="#COM410-编程实践（COM410-Programming-in-Practice）" class="headerlink" title="COM410 编程实践（COM410 Programming in Practice）"></a>COM410 编程实践（COM410 Programming in Practice）</h2><h3 id="A5-1-栈（A5-1-Stacks）"><a href="#A5-1-栈（A5-1-Stacks）" class="headerlink" title="A5.1 栈（A5.1 Stacks）"></a>A5.1 栈（A5.1 Stacks）</h3><h4 id="栈的日常应用（Daily-Applications-of-Stacks）"><a href="#栈的日常应用（Daily-Applications-of-Stacks）" class="headerlink" title="栈的日常应用（Daily Applications of Stacks）"></a>栈的日常应用（Daily Applications of Stacks）</h4><ul>
<li>在日常生活中，栈是一种常见的数据结构，例如书堆、盘子堆、礼物堆等。</li>
<li>当你从栈中移除一个项目时，你总是取走位于顶部的那个。</li>
<li>栈顶的项目是最后被添加进去的。</li>
</ul>
<h4 id="栈的特点（Characteristics-of-Stacks）"><a href="#栈的特点（Characteristics-of-Stacks）" class="headerlink" title="栈的特点（Characteristics of Stacks）"></a>栈的特点（Characteristics of Stacks）</h4><ul>
<li>栈的操作遵循“后进先出”（Last In, First Out，LIFO）原则。</li>
<li>从栈中添加或移除元素通常发生在同一端。</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>本课程的一部分专注于讲解栈这种数据结构，并通过日常生活中的例子来说明它的运作方式。在编程实践中，栈是一种重要的数据结构，适用于需要LIFO操作的场景。理解栈的概念有助于在实际编程任务中更有效地使用它。</p>
<h2 id="栈操作（Stack-Operations）"><a href="#栈操作（Stack-Operations）" class="headerlink" title="栈操作（Stack Operations）"></a>栈操作（Stack Operations）</h2><h3 id="LIFO-行为描述（LIFO-Behavior-Description）"><a href="#LIFO-行为描述（LIFO-Behavior-Description）" class="headerlink" title="LIFO 行为描述（LIFO Behavior Description）"></a>LIFO 行为描述（LIFO Behavior Description）</h3><ul>
<li>栈的行为通常被描述为LIFO（后进先出）。</li>
<li>LIFO 是许多重要实际应用所需的行为。</li>
<li>这类算法使用了栈的抽象数据类型（Stack ADT）。</li>
</ul>
<h3 id="栈的添加和移除操作（Addition-and-Removal-in-Stack）"><a href="#栈的添加和移除操作（Addition-and-Removal-in-Stack）" class="headerlink" title="栈的添加和移除操作（Addition and Removal in Stack）"></a>栈的添加和移除操作（Addition and Removal in Stack）</h3><ul>
<li>在栈中，所有添加都在称为栈顶（top）的一端进行。</li>
<li>栈顶的元素是栈中最新的项目。</li>
<li>向栈中添加条目的操作通常称为 <code>push</code>。</li>
<li>从栈中移除条目的操作通常称为 <code>pop</code>。</li>
</ul>
<h4 id="图解说明（Diagram-Explanation）"><a href="#图解说明（Diagram-Explanation）" class="headerlink" title="图解说明（Diagram Explanation）"></a>图解说明（Diagram Explanation）</h4><ul>
<li>图中展示了一个栈，其中包含了从A到D的元素。</li>
<li><code>push</code> 操作将元素放置到栈顶。</li>
<li><code>pop</code> 操作从栈顶移除元素。</li>
</ul>
<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><p>这部分内容介绍了栈的基本操作和它们的术语。<code>push</code> 和 <code>pop</code> 是栈操作中最基本的两个操作，它们遵循LIFO原则，这在许多编程场景中都是非常重要的。理解这些操作对于学习如何在编程中有效地使用栈至关重要。</p>
<h2 id="栈操作（Stack-Operations）-1"><a href="#栈操作（Stack-Operations）-1" class="headerlink" title="栈操作（Stack Operations）"></a>栈操作（Stack Operations）</h2><h3 id="条目访问限制（Entry-Access-Restrictions）"><a href="#条目访问限制（Entry-Access-Restrictions）" class="headerlink" title="条目访问限制（Entry Access Restrictions）"></a>条目访问限制（Entry Access Restrictions）</h3><ul>
<li>栈限制了对其条目的访问，只能查看或移除栈顶的条目。</li>
</ul>
<h3 id="额外的栈操作（Additional-Stack-Operations）"><a href="#额外的栈操作（Additional-Stack-Operations）" class="headerlink" title="额外的栈操作（Additional Stack Operations）"></a>额外的栈操作（Additional Stack Operations）</h3><ul>
<li>除了 <code>push</code> 和 <code>pop</code> 操作，用于检索栈顶条目但不移除它的操作称为 <code>peek</code>。</li>
</ul>
<h3 id="栈的搜索限制（Search-Limitations-in-Stack）"><a href="#栈的搜索限制（Search-Limitations-in-Stack）" class="headerlink" title="栈的搜索限制（Search Limitations in Stack）"></a>栈的搜索限制（Search Limitations in Stack）</h3><ul>
<li>通常你不能在栈中搜索特定的条目。</li>
<li>查看不在栈顶的条目的唯一方法是重复移除条目，直到想要的条目到达栈顶。</li>
</ul>
<h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><p>这部分内容进一步解释了栈的操作限制，强调了栈结构不支持传统意义上的搜索。<code>peek</code> 操作提供了一种查看栈顶元素而不移除它的方法，这在某些应用场景中非常有用。然而，要访问栈中较低位置的元素，必须通过连续的 <code>pop</code> 操作，这突显了栈结构的LIFO特性和操作限制。</p>
<h2 id="栈操作（Stack-Operations）-2"><a href="#栈操作（Stack-Operations）-2" class="headerlink" title="栈操作（Stack Operations）"></a>栈操作（Stack Operations）</h2><h3 id="push-操作示意（Illustration-of-Push-Operation）"><a href="#push-操作示意（Illustration-of-Push-Operation）" class="headerlink" title="push 操作示意（Illustration of Push Operation）"></a>push 操作示意（Illustration of Push Operation）</h3><ul>
<li>图解显示了执行 <code>push</code> 操作时的栈的变化。</li>
<li>在执行 <code>push(A)</code> 之前，栈是空的或者已有其他元素。</li>
<li>执行 <code>push(A)</code> 后，元素A被添加到了栈的顶部。</li>
</ul>
<h4 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h4><p>这张图很直观地展示了 <code>push</code> 操作如何在栈顶添加一个新元素。这是栈操作中的基础，是数据结构中实现LIFO原则的关键操作之一。理解这个基本概念对于学习如何在编程中操作栈非常重要。</p>
<h2 id="Java-栈的接口（Java-Interface-for-the-Stack-ADT）"><a href="#Java-栈的接口（Java-Interface-for-the-Stack-ADT）" class="headerlink" title="Java 栈的接口（Java Interface for the Stack ADT）"></a>Java 栈的接口（Java Interface for the Stack ADT）</h2><h3 id="StackInterface-接口定义（StackInterface-Definition）"><a href="#StackInterface-接口定义（StackInterface-Definition）" class="headerlink" title="StackInterface 接口定义（StackInterface Definition）"></a>StackInterface<T> 接口定义（StackInterface<T> Definition）</h3><ul>
<li><code>StackInterface&lt;T&gt;</code> 定义了栈的标准操作集合，其中 <code>&lt;T&gt;</code> 是泛型，代表栈可以存储任意类型的对象。</li>
</ul>
<h3 id="接口方法（Interface-Methods）"><a href="#接口方法（Interface-Methods）" class="headerlink" title="接口方法（Interface Methods）"></a>接口方法（Interface Methods）</h3><ul>
<li><code>public void push(T newEntry);</code> - 向栈顶添加一个新的条目。</li>
<li><code>public T pop();</code> - 从栈顶移除一个条目。</li>
<li><code>public T peek();</code> - 返回栈顶的条目，但不移除它。</li>
<li><code>public boolean empty();</code> - 检查栈是否为空，即是否没有条目。</li>
<li><code>public void clear();</code> - 移除栈中的所有条目，清空栈。</li>
</ul>
<h4 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h4><p>该Java接口为栈提供了一种抽象的数据类型表示，允许用户进行标准的栈操作。通过这些方法，用户可以管理栈的内容，不论栈内存储的是何种类型的对象。了解这些方法对于实现和使用栈至关重要，它们构成了栈数据结构的核心功能。</p>
<h2 id="Java-Stack-类（Java-Stack-Class）"><a href="#Java-Stack-类（Java-Stack-Class）" class="headerlink" title="Java Stack 类（Java Stack Class）"></a>Java Stack 类（Java Stack Class）</h2><h3 id="实现栈接口（Implementing-Stack-Interface）"><a href="#实现栈接口（Implementing-Stack-Interface）" class="headerlink" title="实现栈接口（Implementing Stack Interface）"></a>实现栈接口（Implementing Stack Interface）</h3><ul>
<li>在定义栈接口之后，我们可以自行实现所有的方法，就像之前对Bag所做的那样。</li>
</ul>
<h3 id="Java内置的Stack类（Java’s-Built-in-Stack-Class）"><a href="#Java内置的Stack类（Java’s-Built-in-Stack-Class）" class="headerlink" title="Java内置的Stack类（Java’s Built-in Stack Class）"></a>Java内置的Stack类（Java’s Built-in Stack Class）</h3><ul>
<li>Java通过 <code>java.util.Stack</code> 类提供了一个内置的栈实现。</li>
<li>要使用这个内置的栈类，需要在类的顶部导入它：<code>import java.util.Stack;</code>。</li>
</ul>
<h3 id="使用Java-Stack类的代码示例（Code-Example-Using-Java-Stack-Class）"><a href="#使用Java-Stack类的代码示例（Code-Example-Using-Java-Stack-Class）" class="headerlink" title="使用Java Stack类的代码示例（Code Example Using Java Stack Class）"></a>使用Java Stack类的代码示例（Code Example Using Java Stack Class）</h3><ul>
<li>创建栈实例：<code>Stack&lt;String&gt; myStack = new Stack&lt;String&gt;();</code> 表明我们创建了一个可以存储字符串的栈。</li>
<li>Java的Stack类支持泛型，意味着可以为任意类型的对象创建栈。</li>
</ul>
<h4 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h4><p>这部分内容介绍了在Java中使用内置Stack类的方法。我们不需要自己实现栈的所有操作，因为Java提供了一个现成的，支持泛型的栈实现。通过简单地导入和使用 <code>java.util.Stack</code>，我们可以快速开始在程序中使用栈。</p>
<h2 id="Java-Stack-类的使用（Java-Stack-Class-Usage）"><a href="#Java-Stack-类的使用（Java-Stack-Class-Usage）" class="headerlink" title="Java Stack 类的使用（Java Stack Class Usage）"></a>Java Stack 类的使用（Java Stack Class Usage）</h2><ul>
<li><p>使用 <code>empty()</code> 方法检查一个空的 Stack，并且使用 <code>size()</code> 方法报告包含的元素数量</p>
<ul>
<li><code>empty()</code> 方法用来检查栈是否为空，若栈为空，则返回 <code>true</code>。</li>
<li><code>size()</code> 方法返回栈中的元素数量。</li>
</ul>
</li>
<li><p>初始时新创建的 Stack 是空的。</p>
<ul>
<li>当栈被实例化之后，它不包含任何元素，即其 <code>size()</code> 方法返回 <code>0</code>。</li>
</ul>
</li>
</ul>
<h3 id="示例代码解释（Example-Code-Explanation）"><a href="#示例代码解释（Example-Code-Explanation）" class="headerlink" title="示例代码解释（Example Code Explanation）"></a>示例代码解释（Example Code Explanation）</h3><ul>
<li>显示初始栈的状态<ul>
<li>代码中使用 <code>System.out.println()</code> 打印当前栈的状态。</li>
<li>如果栈为空，输出 “Stack is empty”。</li>
<li>如果栈不为空，输出 “Stack contains %d entries”，<code>%d</code> 会被栈的大小所替代。</li>
</ul>
</li>
</ul>
<h3 id="输出结果（Output-Result）"><a href="#输出结果（Output-Result）" class="headerlink" title="输出结果（Output Result）"></a>输出结果（Output Result）</h3><ul>
<li>初始栈显示为空，输出 “[]”<ul>
<li>这表示栈中没有任何元素。</li>
<li>输出 “Stack is empty” 表明 <code>empty()</code> 方法确认了栈是空的。</li>
</ul>
</li>
</ul>
<p>总结：这段Markdown文档详细解释了如何使用Java的Stack类，包括如何检查一个栈是否为空以及如何得知栈中的元素数量。它还包括了如何显示栈的初始状态，并解释了示例代码和输出结果。</p>
<h2 id="Java-栈类的操作（Java-Stack-Class-Operations）"><a href="#Java-栈类的操作（Java-Stack-Class-Operations）" class="headerlink" title="Java 栈类的操作（Java Stack Class Operations）"></a>Java 栈类的操作（Java Stack Class Operations）</h2><ul>
<li><p>使用 <code>push()</code> 方法向栈中添加元素</p>
<ul>
<li><code>push()</code> 方法将一个元素添加到栈顶。</li>
</ul>
</li>
<li><p>新元素被添加到栈的顶部</p>
<ul>
<li>在栈中，最后加入的元素位于顶部，遵循后进先出（LIFO）原则。</li>
</ul>
</li>
</ul>
<h3 id="示例代码解释（Example-Code-Explanation）-1"><a href="#示例代码解释（Example-Code-Explanation）-1" class="headerlink" title="示例代码解释（Example Code Explanation）"></a>示例代码解释（Example Code Explanation）</h3><ul>
<li>向栈中添加元素 “Adrian”、”Belle” 和 “Charles”<ul>
<li>代码首先打印出 “Adding Adrian, Belle and Charles”。</li>
<li>通过 <code>push()</code> 方法依次将 “Adrian”、”Belle” 和 “Charles” 加入到栈中。</li>
</ul>
</li>
</ul>
<h3 id="输出结果（Output-Result）-1"><a href="#输出结果（Output-Result）-1" class="headerlink" title="输出结果（Output Result）"></a>输出结果（Output Result）</h3><ul>
<li>栈中现在包含三个元素：[Adrian, Belle, Charles]<ul>
<li>这个顺序表示 “Charles” 是最后加入的，位于栈顶。</li>
<li>输出 “Stack contains 3 entries” 说明栈中现在有三个元素。</li>
</ul>
</li>
</ul>
<p>总结：此Markdown文档详细介绍了如何使用Java的Stack类的 <code>push()</code> 方法来添加元素。通过示例代码，我们可以看到三个元素按顺序被加入到栈中，并且通过输出结果确认了栈的当前状态和元素数量。</p>
<h2 id="Java-栈类的弹出操作（Java-Stack-Class-Pop-Operation）"><a href="#Java-栈类的弹出操作（Java-Stack-Class-Pop-Operation）" class="headerlink" title="Java 栈类的弹出操作（Java Stack Class Pop Operation）"></a>Java 栈类的弹出操作（Java Stack Class Pop Operation）</h2><ul>
<li><p>使用 <code>pop()</code> 方法从栈中移除元素</p>
<ul>
<li><code>pop()</code> 方法移除并返回栈顶元素，即最后添加进去的元素。</li>
</ul>
</li>
<li><p>元素从栈顶被移除，最近添加的元素（被推入的）会首先被移除（弹出）</p>
<ul>
<li>这符合栈的后进先出（LIFO）原则。</li>
</ul>
</li>
</ul>
<h3 id="示例代码解释（Example-Code-Explanation）-2"><a href="#示例代码解释（Example-Code-Explanation）-2" class="headerlink" title="示例代码解释（Example Code Explanation）"></a>示例代码解释（Example Code Explanation）</h3><ul>
<li>从栈顶移除元素<ul>
<li>代码使用 <code>System.out.println()</code> 方法输出移除操作的提示信息。</li>
<li>执行 <code>myStack.pop()</code> 方法，移除并打印栈顶元素。</li>
</ul>
</li>
</ul>
<h3 id="输出结果（Output-Result）-2"><a href="#输出结果（Output-Result）-2" class="headerlink" title="输出结果（Output Result）"></a>输出结果（Output Result）</h3><ul>
<li>输出结果显示 “Charles” 被移除，栈中剩余 [Adrian, Belle]<ul>
<li>“Charles” 是最后一个被添加进去的元素，因此它是第一个被移除的。</li>
<li>输出 “Stack contains 2 entries” 表明移除后，栈中现在有两个元素。</li>
</ul>
</li>
</ul>
<p>总结：这段Markdown文档详细阐述了Java的Stack类的 <code>pop()</code> 方法，包括如何移除栈顶元素，并通过示例代码和输出结果展示了移除操作前后栈的状态变化。</p>
<h2 id="Java-栈类的查看操作（Java-Stack-Class-Peek-Operation）"><a href="#Java-栈类的查看操作（Java-Stack-Class-Peek-Operation）" class="headerlink" title="Java 栈类的查看操作（Java Stack Class Peek Operation）"></a>Java 栈类的查看操作（Java Stack Class Peek Operation）</h2><ul>
<li><p>使用 <code>peek()</code> 方法从栈中返回元素</p>
<ul>
<li><code>peek()</code> 方法返回栈顶元素，但不会移除它。</li>
</ul>
</li>
<li><p>元素从栈顶返回，但不被移除，<code>peek()</code> 操作不改变栈的内容</p>
<ul>
<li>这使得我们可以查看栈顶元素而不影响栈的状态。</li>
</ul>
</li>
</ul>
<h3 id="示例代码解释（Example-Code-Explanation）-3"><a href="#示例代码解释（Example-Code-Explanation）-3" class="headerlink" title="示例代码解释（Example Code Explanation）"></a>示例代码解释（Example Code Explanation）</h3><ul>
<li>读取栈顶元素<ul>
<li>代码首先输出提示信息 “Reading the element at the top of the stack”。</li>
<li>然后使用 <code>myStack.peek()</code> 方法来返回栈顶元素并打印它。</li>
</ul>
</li>
</ul>
<h3 id="输出结果（Output-Result）-3"><a href="#输出结果（Output-Result）-3" class="headerlink" title="输出结果（Output Result）"></a>输出结果（Output Result）</h3><ul>
<li>输出结果显示栈顶的元素是 “Belle”，而栈的内容仍然是 [Adrian, Belle]<ul>
<li>这表明 <code>peek()</code> 方法成功返回了栈顶元素 “Belle”。</li>
<li>输出 “Stack contains 2 entries” 证实了栈的内容没有因为 <code>peek()</code> 操作而改变。</li>
</ul>
</li>
</ul>
<p>总结：本Markdown文档详细描述了Java的Stack类的 <code>peek()</code> 方法，包括其作用、示例代码及其执行结果，展示了如何查看但不移除栈顶元素，并确认了栈状态保持不变。</p>
<h2 id="Java-栈类的清空操作（Java-Stack-Class-Clear-Operation）"><a href="#Java-栈类的清空操作（Java-Stack-Class-Clear-Operation）" class="headerlink" title="Java 栈类的清空操作（Java Stack Class Clear Operation）"></a>Java 栈类的清空操作（Java Stack Class Clear Operation）</h2><ul>
<li><p>使用 <code>clear()</code> 方法清空栈</p>
<ul>
<li><code>clear()</code> 方法移除栈中的所有元素，使栈回到初始的空状态。</li>
</ul>
</li>
<li><p>清空操作不返回任何元素，但会移除所有元素，<code>clear()</code> 操作使栈恢复到最初的空状态</p>
<ul>
<li>这通常用于重新初始化栈或结束栈的使用。</li>
</ul>
</li>
</ul>
<h3 id="示例代码解释（Example-Code-Explanation）-4"><a href="#示例代码解释（Example-Code-Explanation）-4" class="headerlink" title="示例代码解释（Example Code Explanation）"></a>示例代码解释（Example Code Explanation）</h3><ul>
<li>清空栈中的所有元素<ul>
<li>代码开始先打印出 “Clearing the stack” 作为操作的提示。</li>
<li>然后执行 <code>myStack.clear()</code> 方法来移除所有元素。</li>
</ul>
</li>
</ul>
<h3 id="输出结果（Output-Result）-4"><a href="#输出结果（Output-Result）-4" class="headerlink" title="输出结果（Output Result）"></a>输出结果（Output Result）</h3><ul>
<li>输出结果显示栈已经被清空，输出 “[]”<ul>
<li>这表示栈中没有任何元素，已经回到了初始状态。</li>
<li>输出 “Stack is empty” 确认了栈已经完全为空。</li>
</ul>
</li>
</ul>
<p>总结：本Markdown文档详细描述了Java的Stack类的 <code>clear()</code> 方法，包括其作用、示例代码及其执行结果，展示了如何清空栈中的所有元素，并确认了栈恢复到空状态。</p>
<h2 id="Java-类库中的栈类说明（Note-on-the-Java-Class-Libraries）"><a href="#Java-类库中的栈类说明（Note-on-the-Java-Class-Libraries）" class="headerlink" title="Java 类库中的栈类说明（Note on the Java Class Libraries）"></a>Java 类库中的栈类说明（Note on the Java Class Libraries）</h2><ul>
<li><p>在Java类库中，<code>Stack</code> 是作为 <code>Vector</code> 类的扩展而定义的，而 <code>Vector</code> 类本身实现了 <code>List</code> 接口</p>
<ul>
<li>这表明 <code>Stack</code> 继承了 <code>Vector</code> 的所有属性和方法。</li>
<li><code>List</code> 是一个更为广泛的接口，提供了集合操作的标准方法。</li>
</ul>
</li>
<li><p>即使传统的栈方法 <code>push()</code>、<code>pop()</code> 和 <code>peek()</code> 是添加、访问和移除数据的唯一手段，Java的 <code>Stack</code> 类从其父类继承了非常广泛的方法</p>
<ul>
<li>这些继承来的方法包含了一些非传统栈操作，比如搜索、从中间位置检索等。</li>
<li><code>Stack</code> 类因此具有比传统栈更丰富的功能。</li>
</ul>
</li>
<li><p>我们在这里不会使用这些继承来的方法</p>
<ul>
<li>这可能是为了保持栈的操作简单，防止混淆栈的基本特性。</li>
</ul>
</li>
</ul>
<h3 id="类继承关系图解释（Class-Inheritance-Diagram-Explanation）"><a href="#类继承关系图解释（Class-Inheritance-Diagram-Explanation）" class="headerlink" title="类继承关系图解释（Class Inheritance Diagram Explanation）"></a>类继承关系图解释（Class Inheritance Diagram Explanation）</h3><ul>
<li><p><code>Iterable</code> 接口被 <code>Collection</code> 接口扩展，<code>Collection</code> 接口又被 <code>List</code> 接口扩展</p>
<ul>
<li>这是Java集合框架中的基本结构，定义了集合的基本行为和操作。</li>
</ul>
</li>
<li><p><code>List</code> 接口被 <code>Vector</code> 类实现，然后 <code>Stack</code> 类扩展了 <code>Vector</code> 类</p>
<ul>
<li>说明 <code>Stack</code> 既有 <code>List</code> 的特性也有 <code>Vector</code> 的特性。</li>
<li><code>Vector</code> 提供了数组动态数组的功能，而 <code>Stack</code> 在此基础上添加了LIFO（后进先出）的操作。</li>
</ul>
</li>
</ul>
<p>总结：本Markdown文档提供了关于Java类库中栈类的详细说明。讨论了 <code>Stack</code> 类与 <code>Vector</code> 和 <code>List</code> 的关系，指出 <code>Stack</code> 继承了许多非传统的栈操作方法，但在当前的上下文中，我们不使用这些方法。同时，还详细解释了类继承关系图，说明了Java集合框架的继承结构。</p>
<h2 id="Java-项目实践场景：栈操作（Scenario-Stack-Operations-in-Java-Project）"><a href="#Java-项目实践场景：栈操作（Scenario-Stack-Operations-in-Java-Project）" class="headerlink" title="Java 项目实践场景：栈操作（Scenario: Stack Operations in Java Project）"></a>Java 项目实践场景：栈操作（Scenario: Stack Operations in Java Project）</h2><ul>
<li><p>我们已经看到如何将一系列元素推入栈中，然后再弹出，以此来检索元素，且检索顺序与最初的顺序相反。</p>
<ul>
<li>这展示了栈的后进先出（LIFO）特性。</li>
</ul>
</li>
<li><p>创建一个新的Java项目 <code>DataStructures</code> 和一个名为 <code>Stacks</code> 的类，在这个类的 <code>main()</code> 方法中实现字符串反转和回文检查的应用程序，如下所述：</p>
<ul>
<li>用户应当被提示从键盘输入一个字符串。</li>
<li>应当逐个字符检索字符串，从第一个字符开始，并将它们推入栈中。</li>
<li>所有字符都被推入栈后，应当逐个弹出，并将这些字符连接成一个单独的字符串。</li>
<li>如果反转后的字符串与原始字符串相同，则显示信息 “<string>是一个回文”，其中<string>是用户提供的原始字符串。</li>
</ul>
</li>
</ul>
<h3 id="实践场景详解（Detailed-Explanation-of-the-Scenario）"><a href="#实践场景详解（Detailed-Explanation-of-the-Scenario）" class="headerlink" title="实践场景详解（Detailed Explanation of the Scenario）"></a>实践场景详解（Detailed Explanation of the Scenario）</h3><ul>
<li><p>首先，需要从用户那里获取输入，然后处理每一个字符</p>
<ul>
<li>通常涉及使用 <code>Scanner</code> 类或其他输入方法来从命令行读取。</li>
</ul>
</li>
<li><p>其次，字符入栈和出栈的过程实现了字符串的反转</p>
<ul>
<li>栈的特性保证了出栈顺序与入栈顺序相反，从而实现反转。</li>
</ul>
</li>
<li><p>最后，通过比较反转后的字符串和原始字符串来检查是否为回文</p>
<ul>
<li>这是一个简单的字符串比较操作。</li>
</ul>
</li>
</ul>
<p>总结：本Markdown文档描述了一个Java项目实践场景，要求创建一个程序来演示使用栈进行字符串反转和回文检查。详细说明了程序的要求和步骤，包括用户交互、字符处理、栈操作以及结果验证。这个练习不仅加深了对栈结构的理解，还提供了实际应用栈进行问题解决的实例。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Jacka10086</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/12/16/A5-1/">http://example.com/2023/12/16/A5-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/10/18/fq6OmvaUIxkbdo5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/16/A5-2/" title="A5-2"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">A5-2</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/16/A4-3/" title="A4-3"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">A4-3</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/10/18/fq6OmvaUIxkbdo5.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jacka10086</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">112</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Jacka10086"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#COM410-%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%EF%BC%88COM410-Programming-in-Practice%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">COM410 编程实践（COM410 Programming in Practice）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A5-1-%E6%A0%88%EF%BC%88A5-1-Stacks%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">A5.1 栈（A5.1 Stacks）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%97%A5%E5%B8%B8%E5%BA%94%E7%94%A8%EF%BC%88Daily-Applications-of-Stacks%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">栈的日常应用（Daily Applications of Stacks）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%88Characteristics-of-Stacks%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">栈的特点（Characteristics of Stacks）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.1.3.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%93%8D%E4%BD%9C%EF%BC%88Stack-Operations%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">栈操作（Stack Operations）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LIFO-%E8%A1%8C%E4%B8%BA%E6%8F%8F%E8%BF%B0%EF%BC%88LIFO-Behavior-Description%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">LIFO 行为描述（LIFO Behavior Description）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%B7%BB%E5%8A%A0%E5%92%8C%E7%A7%BB%E9%99%A4%E6%93%8D%E4%BD%9C%EF%BC%88Addition-and-Removal-in-Stack%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">栈的添加和移除操作（Addition and Removal in Stack）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E8%A7%A3%E8%AF%B4%E6%98%8E%EF%BC%88Diagram-Explanation%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">图解说明（Diagram Explanation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%93%8D%E4%BD%9C%EF%BC%88Stack-Operations%EF%BC%89-1"><span class="toc-number">3.</span> <span class="toc-text">栈操作（Stack Operations）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E7%9B%AE%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%EF%BC%88Entry-Access-Restrictions%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">条目访问限制（Entry Access Restrictions）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E6%A0%88%E6%93%8D%E4%BD%9C%EF%BC%88Additional-Stack-Operations%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">额外的栈操作（Additional Stack Operations）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%90%9C%E7%B4%A2%E9%99%90%E5%88%B6%EF%BC%88Search-Limitations-in-Stack%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">栈的搜索限制（Search Limitations in Stack）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%93%8D%E4%BD%9C%EF%BC%88Stack-Operations%EF%BC%89-2"><span class="toc-number">4.</span> <span class="toc-text">栈操作（Stack Operations）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#push-%E6%93%8D%E4%BD%9C%E7%A4%BA%E6%84%8F%EF%BC%88Illustration-of-Push-Operation%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">push 操作示意（Illustration of Push Operation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-3"><span class="toc-number">4.1.1.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%A0%88%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%88Java-Interface-for-the-Stack-ADT%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">Java 栈的接口（Java Interface for the Stack ADT）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StackInterface-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%EF%BC%88StackInterface-Definition%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">StackInterface 接口定义（StackInterface Definition）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%EF%BC%88Interface-Methods%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">接口方法（Interface Methods）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-4"><span class="toc-number">5.2.1.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Stack-%E7%B1%BB%EF%BC%88Java-Stack-Class%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">Java Stack 类（Java Stack Class）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%A0%88%E6%8E%A5%E5%8F%A3%EF%BC%88Implementing-Stack-Interface%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">实现栈接口（Implementing Stack Interface）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E7%BD%AE%E7%9A%84Stack%E7%B1%BB%EF%BC%88Java%E2%80%99s-Built-in-Stack-Class%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">Java内置的Stack类（Java’s Built-in Stack Class）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Java-Stack%E7%B1%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%88Code-Example-Using-Java-Stack-Class%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">使用Java Stack类的代码示例（Code Example Using Java Stack Class）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-5"><span class="toc-number">6.3.1.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Stack-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88Java-Stack-Class-Usage%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">Java Stack 类的使用（Java Stack Class Usage）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%EF%BC%88Example-Code-Explanation%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">示例代码解释（Example Code Explanation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%EF%BC%88Output-Result%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">输出结果（Output Result）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%A0%88%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%88Java-Stack-Class-Operations%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">Java 栈类的操作（Java Stack Class Operations）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%EF%BC%88Example-Code-Explanation%EF%BC%89-1"><span class="toc-number">8.1.</span> <span class="toc-text">示例代码解释（Example Code Explanation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%EF%BC%88Output-Result%EF%BC%89-1"><span class="toc-number">8.2.</span> <span class="toc-text">输出结果（Output Result）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%A0%88%E7%B1%BB%E7%9A%84%E5%BC%B9%E5%87%BA%E6%93%8D%E4%BD%9C%EF%BC%88Java-Stack-Class-Pop-Operation%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">Java 栈类的弹出操作（Java Stack Class Pop Operation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%EF%BC%88Example-Code-Explanation%EF%BC%89-2"><span class="toc-number">9.1.</span> <span class="toc-text">示例代码解释（Example Code Explanation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%EF%BC%88Output-Result%EF%BC%89-2"><span class="toc-number">9.2.</span> <span class="toc-text">输出结果（Output Result）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%A0%88%E7%B1%BB%E7%9A%84%E6%9F%A5%E7%9C%8B%E6%93%8D%E4%BD%9C%EF%BC%88Java-Stack-Class-Peek-Operation%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">Java 栈类的查看操作（Java Stack Class Peek Operation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%EF%BC%88Example-Code-Explanation%EF%BC%89-3"><span class="toc-number">10.1.</span> <span class="toc-text">示例代码解释（Example Code Explanation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%EF%BC%88Output-Result%EF%BC%89-3"><span class="toc-number">10.2.</span> <span class="toc-text">输出结果（Output Result）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%A0%88%E7%B1%BB%E7%9A%84%E6%B8%85%E7%A9%BA%E6%93%8D%E4%BD%9C%EF%BC%88Java-Stack-Class-Clear-Operation%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">Java 栈类的清空操作（Java Stack Class Clear Operation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%EF%BC%88Example-Code-Explanation%EF%BC%89-4"><span class="toc-number">11.1.</span> <span class="toc-text">示例代码解释（Example Code Explanation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%EF%BC%88Output-Result%EF%BC%89-4"><span class="toc-number">11.2.</span> <span class="toc-text">输出结果（Output Result）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84%E6%A0%88%E7%B1%BB%E8%AF%B4%E6%98%8E%EF%BC%88Note-on-the-Java-Class-Libraries%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">Java 类库中的栈类说明（Note on the Java Class Libraries）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE%E8%A7%A3%E9%87%8A%EF%BC%88Class-Inheritance-Diagram-Explanation%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">类继承关系图解释（Class Inheritance Diagram Explanation）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E5%9C%BA%E6%99%AF%EF%BC%9A%E6%A0%88%E6%93%8D%E4%BD%9C%EF%BC%88Scenario-Stack-Operations-in-Java-Project%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">Java 项目实践场景：栈操作（Scenario: Stack Operations in Java Project）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E5%9C%BA%E6%99%AF%E8%AF%A6%E8%A7%A3%EF%BC%88Detailed-Explanation-of-the-Scenario%EF%BC%89"><span class="toc-number">13.1.</span> <span class="toc-text">实践场景详解（Detailed Explanation of the Scenario）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/23/301%E7%AC%AC%E5%9B%9B%E5%91%A8Lab7/" title="301第四周Lab7">301第四周Lab7</a><time datetime="2024-02-23T16:17:37.000Z" title="Created 2024-02-23 16:17:37">2024-02-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/23/301%E7%AC%AC%E5%9B%9B%E5%91%A8TUL/" title="301第四周TUL">301第四周TUL</a><time datetime="2024-02-23T15:49:54.000Z" title="Created 2024-02-23 15:49:54">2024-02-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/19/301%E7%AC%AC%E5%9B%9B%E5%91%A8LEC/" title="301第四周LEC">301第四周LEC</a><time datetime="2024-02-19T21:43:03.000Z" title="Created 2024-02-19 21:43:03">2024-02-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/14/431%E7%AC%AC%E4%B8%89%E5%91%A8LEC/" title="431第三周LEC">431第三周LEC</a><time datetime="2024-02-14T21:42:49.000Z" title="Created 2024-02-14 21:42:49">2024-02-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/14/301%E7%AC%AC%E4%B8%89%E5%91%A8LAB6/" title="301第三周LAB6">301第三周LAB6</a><time datetime="2024-02-14T21:14:34.000Z" title="Created 2024-02-14 21:14:34">2024-02-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Jacka10086</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>