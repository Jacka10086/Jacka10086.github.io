<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Week5-pratical | Jacka10086's Blog</title><meta name="author" content="Jacka10086"><meta name="copyright" content="Jacka10086"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Card.java解释 Card.ranks.length这是获取扑克牌点数数组长度的表达式。  Card.ranks: 这是Card类中定义的一个字符串数组，代表扑克牌的所有点数。  .length: 这是获取数组长度的属性。对于数组，.length返回数组的元素数量。   假设在Card类中，ranks数组定义如下： 1public static final String[] ranks &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="Week5-pratical">
<meta property="og:url" content="http://example.com/2023/10/28/Week5-pratical/index.html">
<meta property="og:site_name" content="Jacka10086&#39;s Blog">
<meta property="og:description" content="Card.java解释 Card.ranks.length这是获取扑克牌点数数组长度的表达式。  Card.ranks: 这是Card类中定义的一个字符串数组，代表扑克牌的所有点数。  .length: 这是获取数组长度的属性。对于数组，.length返回数组的元素数量。   假设在Card类中，ranks数组定义如下： 1public static final String[] ranks &#x3D;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2023/10/18/fq6OmvaUIxkbdo5.jpg">
<meta property="article:published_time" content="2023-10-28T01:19:13.000Z">
<meta property="article:modified_time" content="2023-10-28T02:32:51.123Z">
<meta property="article:author" content="Jacka10086">
<meta property="article:tag" content="practical">
<meta property="article:tag" content="Week5">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/10/18/fq6OmvaUIxkbdo5.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/10/28/Week5-pratical/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Week5-pratical',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-28 03:32:51'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2023/10/18/fq6OmvaUIxkbdo5.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">112</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Jacka10086's Blog"><span class="site-name">Jacka10086's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Week5-pratical</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-10-28T01:19:13.000Z" title="Created 2023-10-28 02:19:13">2023-10-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-10-28T02:32:51.123Z" title="Updated 2023-10-28 03:32:51">2023-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Com410/">Com410</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Week5-pratical"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Card-java"><a href="#Card-java" class="headerlink" title="Card.java"></a>Card.java</h1><h2 id="解释-Card-ranks-length"><a href="#解释-Card-ranks-length" class="headerlink" title="解释 Card.ranks.length"></a>解释 <code>Card.ranks.length</code></h2><p>这是获取扑克牌点数数组长度的表达式。</p>
<ul>
<li><p><strong>Card.ranks</strong>: 这是<code>Card</code>类中定义的一个字符串数组，代表扑克牌的所有点数。</p>
</li>
<li><p><strong>.length</strong>: 这是获取数组长度的属性。对于数组，<code>.length</code>返回数组的元素数量。</p>
</li>
</ul>
<p>假设在<code>Card</code>类中，<code>ranks</code>数组定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] ranks = &#123;<span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Queen&quot;</span>, <span class="string">&quot;King&quot;</span>, <span class="string">&quot;Ace&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>则Card.ranks.length的值为13，因为数组中有13种不同的点数。</p>
<p>这个属性常常在循环或随机选择扑克牌点数时使用，确保所选的索引始终在有效范围内。</p>
<h2 id="解释-nextInt"><a href="#解释-nextInt" class="headerlink" title="解释 nextInt"></a>解释 nextInt</h2><p><code>nextInt</code> 是 <code>java.util.Random</code> 类中的一个方法，它用于生成伪随机的整数值。</p>
<ul>
<li><p><strong>方法描述</strong>:</p>
<ul>
<li><code>nextInt()</code>: 生成一个表示为32位的正数和负数的随机整数。</li>
<li><code>nextInt(n)</code>: 生成一个范围在 [0, n) 内的随机整数，即从0（包括）到 n（不包括）。</li>
</ul>
</li>
<li><p><strong>如何使用</strong>:</p>
<ol>
<li>首先，你需要导入 <code>java.util.Random</code> 类并创建其对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>nextInt</code> 方法来获取随机整数。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">randomValue</span> <span class="operator">=</span> random.nextInt();       <span class="comment">// 生成一个随机整数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">randomValueBetween0And10</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>); <span class="comment">// 生成一个0到9之间的随机整数</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p><strong>注意事项</strong>:</p>
<ul>
<li>使用 <code>nextInt(n)</code> 时，确保 n 是正数，否则会抛出 <code>IllegalArgumentException</code>。</li>
<li>由于是伪随机数生成器，给定相同的种子，它总是产生相同的序列。但在默认情况下，种子是基于当前时间的，因此每次得到的随机序列都是不同的。</li>
</ul>
</li>
</ul>
<p>以上就是 <code>nextInt</code> 方法的简要解释和如何使用它的示例。</p>
<h2 id="解释-this-rank-rank"><a href="#解释-this-rank-rank" class="headerlink" title="解释 this.rank &#x3D; rank;"></a>解释 this.rank &#x3D; rank;</h2><p><code>this.rank = rank;</code> 是 Java 中的赋值语句，用于初始化对象的属性。</p>
<ul>
<li><p><strong>含义</strong>:</p>
<ul>
<li><code>this.rank</code>：指代当前对象的 <code>rank</code> 属性。</li>
<li><code>rank</code>：指代传递给方法或构造函数的局部变量或参数。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:<br>在 Java 中，当方法的局部变量或参数与类的属性同名时，可以使用 <code>this</code> 关键字来区分它们。在此情境中，<code>this.rank</code> 指代类的属性，而 <code>rank</code> 指代构造函数或方法的参数。</p>
</li>
<li><p><strong>使用场景</strong>:<br>这种赋值语句通常在构造函数中使用，以初始化对象的属性。例如，当创建 <code>Card</code> 类的新实例时，我们可能想要为其 <code>rank</code> 属性赋值。</p>
</li>
</ul>
<h3 id="解释-public-String-getRank-return-Card-ranks-this-rank"><a href="#解释-public-String-getRank-return-Card-ranks-this-rank" class="headerlink" title="解释 public String getRank() { return Card.ranks[this.rank]; }"></a>解释 public String getRank() { return Card.ranks[this.rank]; }</h3><p>该方法是 <code>Card</code> 类中的一个成员方法，用于获取卡片的点数名称。</p>
<ul>
<li><p><strong>方法定义</strong>:</p>
<ul>
<li><code>public</code>：这是一个访问修饰符，表示该方法可以被任何其他类访问。</li>
<li><code>String</code>：表示该方法的返回类型是字符串。</li>
<li><code>getRank()</code>：是方法的名称，符合 Java 的命名规范，即用 “get” 前缀来获取类的属性。</li>
</ul>
</li>
<li><p><strong>方法内容</strong>:</p>
<ul>
<li><code>Card.ranks</code>：是一个预定义的字符串数组，存储了所有可能的扑克牌点数。</li>
<li><code>this.rank</code>：表示当前 <code>Card</code> 对象的 <code>rank</code> 属性。这是一个整数，表示卡片的点数索引。</li>
<li><code>Card.ranks[this.rank]</code>：通过索引从数组中获取相应的点数名称。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:<br>当你创建了一个 <code>Card</code> 对象并设置了其点数属性后，你可以通过调用这个方法来获取其点数名称。例如，如果 <code>rank</code> 的值是 0，该方法将返回 “2”（假设 <code>Card.ranks</code> 数组的第一个元素是 “2”）。</p>
</li>
</ul>
<h2 id="解释-public-boolean-isBiggerThan-Card-otherCard-return-this-rank-otherCard-rank"><a href="#解释-public-boolean-isBiggerThan-Card-otherCard-return-this-rank-otherCard-rank" class="headerlink" title="解释 public boolean isBiggerThan(Card otherCard) { return this.rank &gt; otherCard.rank; }"></a>解释 public boolean isBiggerThan(Card otherCard) { return this.rank &gt; otherCard.rank; }</h2><p>这是 <code>Card</code> 类中的一个成员方法，用于判断当前卡片的点数是否大于另一张卡片的点数。</p>
<ul>
<li><p><strong>方法定义</strong>:</p>
<ul>
<li><code>public</code>：这是一个访问修饰符，表示该方法可以被任何其他类访问。</li>
<li><code>boolean</code>：表示该方法的返回类型是布尔值，即 true 或 false。</li>
<li><code>isBiggerThan(Card otherCard)</code>：是方法的名称，并带有一个 <code>Card</code> 类型的参数 <code>otherCard</code>。</li>
</ul>
</li>
<li><p><strong>方法内容</strong>:</p>
<ul>
<li><code>this.rank</code>：表示当前 <code>Card</code> 对象的 <code>rank</code> 属性，这是一个整数，代表卡片的点数索引。</li>
<li><code>otherCard.rank</code>：表示参数卡片 <code>otherCard</code> 的点数索引。</li>
<li><code>this.rank &gt; otherCard.rank</code>：这是一个布尔表达式，比较当前卡片的点数是否大于参数卡片的点数。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:<br>当你拥有两张 <code>Card</code> 对象，并想知道其中一张是否有更大的点数，你可以使用这个方法进行比较。例如，如果当前卡片的 <code>rank</code> 是 10（代表 “Jack”）而 <code>otherCard</code> 的 <code>rank</code> 是 8（代表 “9”），则该方法将返回 true。</p>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Card</span> <span class="variable">card1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>(<span class="number">10</span>, <span class="string">&quot;Hearts&quot;</span>);</span><br><span class="line"><span class="type">Card</span> <span class="variable">card2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Card</span>(<span class="number">8</span>, <span class="string">&quot;Spades&quot;</span>);</span><br><span class="line">System.out.println(card1.isBiggerThan(card2));  <span class="comment">// 输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p>上述代码创建了两个 Card 对象，并使用 isBiggerThan() 方法比较它们的点数大小。</p>
</li>
</ul>
<h1 id="CardTest-java"><a href="#CardTest-java" class="headerlink" title="CardTest.java"></a>CardTest.java</h1><h2 id="解释-Deck-deck-new-Deck"><a href="#解释-Deck-deck-new-Deck" class="headerlink" title="解释 Deck deck &#x3D; new Deck();"></a>解释 Deck deck &#x3D; new Deck();</h2><p>这行代码创建了一个名为 <code>deck</code> 的新扑克牌堆对象。</p>
<ul>
<li><p><strong>组件解析</strong>:</p>
<ul>
<li><code>Deck</code>：这是一个类的名称，通常用于表示一副完整的扑克牌。</li>
<li><code>deck</code>：这是我们为新创建的对象选择的变量名称。</li>
<li><code>new</code>：Java 中的关键字，用于实例化对象。</li>
<li><code>Deck()</code>：这是 <code>Deck</code> 类的构造函数，它初始化一个新的 <code>Deck</code> 对象。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:<br>当这行代码执行时，它会做以下几件事情：</p>
<ol>
<li>使用 <code>Deck</code> 类的默认构造函数创建一个新的 <code>Deck</code> 对象。</li>
<li>初始化这个新对象（通常是将一副扑克牌初始化为标准的 52 张牌，但具体的实现取决于 <code>Deck</code> 类的定义）。</li>
<li>将这个新创建的 <code>Deck</code> 对象的引用赋值给变量 <code>deck</code>，这样我们就可以在后续的代码中使用这个变量来操作这副牌。</li>
</ol>
</li>
</ul>
<h2 id="解释-System-out-println-deck-deal"><a href="#解释-System-out-println-deck-deal" class="headerlink" title="解释 System.out.println(deck.deal());"></a>解释 System.out.println(deck.deal());</h2><p>这行代码从一副牌中发出一张牌并在控制台上打印这张牌的信息。</p>
<ul>
<li><p><strong>组件解析</strong>:</p>
<ul>
<li><code>System.out.println</code>: 这是Java中用于向控制台输出信息的标准方法。</li>
<li><code>deck</code>: 一个已经初始化的 <code>Deck</code> 类型的对象。</li>
<li><code>deal()</code>: <code>Deck</code> 类中的一个方法，通常用于发出牌堆中的一张牌。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ol>
<li>当 <code>deck.deal()</code> 被调用时，它会从牌堆中选择一张牌并返回这张牌，同时将这张牌从牌堆中移除。</li>
<li>返回的牌对象的 <code>toString()</code> 方法会被调用，以便将其转换为字符串表示形式。</li>
<li><code>System.out.println</code> 将这个字符串打印到控制台。</li>
</ol>
</li>
</ul>
<h1 id="Deck-java"><a href="#Deck-java" class="headerlink" title="Deck.java"></a>Deck.java</h1><h2 id="解释-System-out-println-deck-deal-1"><a href="#解释-System-out-println-deck-deal-1" class="headerlink" title="解释 System.out.println(deck.deal());"></a>解释 System.out.println(deck.deal());</h2><p>这行代码从一副牌中发出一张牌并在控制台上打印这张牌的信息。</p>
<ul>
<li><p><strong>组件解析</strong>:</p>
<ul>
<li><code>System.out.println</code>: 这是Java中用于向控制台输出信息的标准方法。</li>
<li><code>deck</code>: 一个已经初始化的 <code>Deck</code> 类型的对象。</li>
<li><code>deal()</code>: <code>Deck</code> 类中的一个方法，通常用于发出牌堆中的一张牌。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ol>
<li>当 <code>deck.deal()</code> 被调用时，它会从牌堆中选择一张牌并返回这张牌，同时将这张牌从牌堆中移除。</li>
<li>返回的牌对象的 <code>toString()</code> 方法会被调用，以便将其转换为字符串表示形式。</li>
<li><code>System.out.println</code> 将这个字符串打印到控制台。</li>
</ol>
</li>
</ul>
<h2 id="解释-this-deck-add-new-Card-i-13-i-13"><a href="#解释-this-deck-add-new-Card-i-13-i-13" class="headerlink" title="解释 this.deck.add(new Card(i % 13, i &#x2F; 13));"></a>解释 this.deck.add(new Card(i % 13, i &#x2F; 13));</h2><p>这行代码是在构造一个标准的扑克牌堆，其中包含 4 种花色的 13 张牌。</p>
<ul>
<li><p><strong>组件解析</strong>:</p>
<ul>
<li><code>this.deck</code>: 这是一个容器（通常是一个列表或集合），用于存储 <code>Card</code> 对象，即一副扑克牌。</li>
<li><code>add()</code>: 这是一个方法，用于将一个元素添加到容器中。</li>
<li><code>new Card(i % 13, i / 13)</code>: 这是创建新的 <code>Card</code> 对象的代码，其中传递给构造函数的参数分别是牌的点数和花色。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li><code>i % 13</code>: 使用模运算符 <code>%</code> 计算 <code>i</code> 除以 13 的余数，取值范围是 0 到 12。这表示一种花色中的 13 张牌的点数。</li>
<li><code>i / 13</code>: 使用整数除法 <code>/</code> 计算 <code>i</code> 除以 13 的商，取值范围是 0 到 3。这表示牌的 4 种花色。</li>
</ul>
<p>这种方法使用一个循环变量 <code>i</code>（通常在一个循环中递增，从 0 到 51）为一副扑克牌中的每张牌生成正确的点数和花色。</p>
</li>
</ul>
<h2 id="解释-if-this-deck-size-0-…"><a href="#解释-if-this-deck-size-0-…" class="headerlink" title="解释 if (this.deck.size() &gt; 0) { … }"></a>解释 if (this.deck.size() &gt; 0) { … }</h2><p>这段代码描述了如何从一副牌的顶部发出一张牌的操作。</p>
<ul>
<li><p><strong>组件解析</strong>:</p>
<ul>
<li><code>this.deck</code>: 这是一个容器（通常是一个列表或集合），用于存储 <code>Card</code> 对象，即一副扑克牌。</li>
<li><code>size()</code>: 这是一个方法，返回容器中的元素数量。</li>
<li><code>get(0)</code>: 这是从容器中获取第一个元素的方法。</li>
<li><code>remove(0)</code>: 这是从容器中移除第一个元素的方法。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li><code>if (this.deck.size() &gt; 0)</code>: 首先，检查牌堆是否为空，即是否还有卡牌。</li>
<li><code>Card card = this.deck.get(0)</code>: 如果还有卡牌，则获取牌堆顶部的卡牌。</li>
<li><code>this.deck.remove(0)</code>: 接着，从牌堆中移除这张牌。</li>
<li><code>return card</code>: 最后，返回这张卡牌。</li>
</ul>
</li>
<li><p><strong>示例应用场景</strong>:<br>当玩家要从牌堆中抽一张牌时，这段代码就会执行。如果牌堆是空的，该方法可能会返回 <code>null</code> 或执行其他逻辑（根据完整代码的其他部分）。</p>
</li>
</ul>
<p>这段代码确保只有在牌堆中还有卡牌时，才会执行抽牌的操作，从而避免了在空牌堆中尝试抽牌的错误。</p>
<h2 id="解释-public-String-toString-…"><a href="#解释-public-String-toString-…" class="headerlink" title="解释 public String toString() { … }"></a>解释 public String toString() { … }</h2><p>这段代码描述了如何将一个 <code>Deck</code> 对象转化为其字符串形式，显示其中的每张卡牌。</p>
<ul>
<li><p><strong>组件解析</strong>:</p>
<ul>
<li><code>toString()</code>: 这是Java中的一个特殊方法，用于定义一个对象的字符串表示。</li>
<li><code>this.deck</code>: 这是一个容器，包含 <code>Card</code> 对象，代表一副扑克牌。</li>
<li><code>for (Card card : this.deck)</code>: 这是一个增强型的for循环，用于遍历容器中的每一个元素。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li><code>String resultStr = &quot;\n&quot;</code>: 创建一个字符串变量 <code>resultStr</code> 并初始化为一个换行符，为了格式化输出。</li>
<li><code>for (Card card : this.deck)</code>: 遍历牌堆中的每一张牌。</li>
<li><code>resultStr += card + &quot;\n&quot;</code>: 对于牌堆中的每张牌，调用其 <code>toString()</code> 方法（此方法应已被定义在 <code>Card</code> 类中）获取其字符串表示，然后添加到 <code>resultStr</code> 中并跟上一个换行符。</li>
<li><code>return resultStr</code>: 返回表示整个牌堆的字符串。</li>
</ul>
</li>
<li><p><strong>示例应用场景</strong>:<br>当你想要打印整个牌堆的内容或将其显示在屏幕上时，可以调用这个 <code>toString()</code> 方法。例如，使用 <code>System.out.println(deck)</code> 会自动调用 <code>deck</code> 对象的 <code>toString()</code> 方法，并打印整个牌堆的内容。</p>
</li>
</ul>
<p>这个方法提供了一个简洁、格式化的方式来查看 <code>Deck</code> 对象中所有卡牌的详细信息。</p>
<h2 id="解释-for-Card-card-this-deck"><a href="#解释-for-Card-card-this-deck" class="headerlink" title="解释 for (Card card : this.deck)"></a>解释 for (Card card : this.deck)</h2><p>这段代码展示了如何使用增强型的for循环 (<code>for-each</code> 循环) 来遍历 Deck 类中的每张卡牌。</p>
<ul>
<li><p><strong>组件解析</strong>:</p>
<ul>
<li><code>for (Card card : this.deck)</code>: 这是一个增强型的for循环，被设计用来遍历集合或数组。</li>
<li><code>Card</code>: 是一个自定义数据类型，代表一张扑克牌。</li>
<li><code>this.deck</code>: 是一个集合（例如 <code>ArrayList</code>），其中包含了 <code>Card</code> 对象，代表一副扑克牌。</li>
</ul>
</li>
<li><p><strong>工作原理</strong>:</p>
<ul>
<li>在每次循环迭代中，<code>this.deck</code> 的下一张卡牌会被取出并赋值给变量 <code>card</code>。</li>
<li>这样，开发者可以在循环体中直接使用 <code>card</code> 变量对每张卡牌进行操作。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>:<br>使用这种循环结构非常适合于你需要对集合或数组中的每个元素执行某种操作，但并不需要知道元素的索引。例如，当你想要打印每张卡牌的信息或者修改其属性时。</p>
</li>
</ul>
<p>简而言之，这个增强型的for循环提供了一个简洁且易读的方法来遍历 <code>Deck</code> 对象中的每一张卡牌。</p>
<h2 id="解释-public-static-void-main-String-args"><a href="#解释-public-static-void-main-String-args" class="headerlink" title="解释 public static void main(String[] args)"></a>解释 public static void main(String[] args)</h2><p><code>public static void main(String[] args)</code> 在 Java 中有特殊的重要性，它是 Java 应用程序的入口点。</p>
<ul>
<li><p><strong>组成部分</strong>：</p>
<ul>
<li><code>public</code>: 修饰符表示该方法是公开的，可从其他类和包访问。</li>
<li><code>static</code>: 修饰符表示这是一个静态方法，因此它属于类而不是类的任何特定实例。这意味着我们不需要创建类的对象来调用这个方法。</li>
<li><code>void</code>: 表示该方法没有返回任何值。</li>
<li><code>main</code>: 是该方法的名称。</li>
<li><code>String[] args</code>: 是该方法的参数，是一个字符串数组。它用于从命令行接收参数。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>当您运行一个 Java 程序时，JVM 会首先查找一个名为 <code>main</code> 的方法，并从那里开始执行。</li>
<li>该方法作为程序的入口点，意味着程序的执行从这里开始，并在此方法完成后结束。</li>
</ul>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li>主要用于接收和处理命令行参数。</li>
<li>启动和初始化应用程序。</li>
</ul>
</li>
</ul>
<p>简而言之，无论您的 Java 程序的复杂性如何，JVM 总是从 <code>public static void main(String[] args)</code> 开始执行。如果没有这个方法，Java 应用程序将无法启动。</p>
<h2 id="解释-Scanner-keyboard-new-Scanner-System-in"><a href="#解释-Scanner-keyboard-new-Scanner-System-in" class="headerlink" title="解释 Scanner keyboard &#x3D; new Scanner(System.in);"></a>解释 Scanner keyboard &#x3D; new Scanner(System.in);</h2><p><code>Scanner keyboard = new Scanner(System.in);</code> 是 Java 中常用的一行代码，它的功能是为从控制台获取输入创建一个对象。</p>
<ul>
<li><p><strong>组成部分</strong>：</p>
<ul>
<li><code>Scanner</code>: 是 Java 的 <code>java.util</code> 包中的一个类，用于解析文本并从输入流中获取数据。</li>
<li><code>keyboard</code>: 是我们为新创建的 Scanner 对象定义的变量名。</li>
<li><code>new</code>: 是 Java 的一个关键字，用于创建对象。</li>
<li><code>System.in</code>: 是 Java 的标准输入流，通常表示键盘输入。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>这行代码创建了一个新的 Scanner 对象，该对象配置为从标准输入流（即键盘）读取数据。</li>
<li>之后，你可以使用 <code>keyboard</code> 对象来调用 Scanner 类的方法，如 <code>next()</code>, <code>nextInt()</code>, 和 <code>nextLine()</code> 等，以读取用户从控制台输入的数据。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>当你需要在 Java 程序中读取用户输入时，这行代码非常有用。例如，你可能想要询问用户一个问题，并根据他们的答案执行不同的操作。</li>
</ul>
</li>
</ul>
<p>简而言之，通过这行代码，Java 程序可以简单地从控制台读取用户输入，并将这些输入用作程序的一部分。</p>
<h2 id="解释-Queue-letters-new-LinkedList"><a href="#解释-Queue-letters-new-LinkedList" class="headerlink" title="解释 Queue letters &#x3D; new LinkedList();"></a>解释 Queue<Character> letters &#x3D; new LinkedList<Character>();</h2><p>在这行代码中，我们正在初始化一个队列数据结构，并使用链表来实现它。</p>
<ul>
<li><p><strong>组成部分</strong>：</p>
<ul>
<li><code>Queue&lt;Character&gt;</code>：这表示我们正在声明一个队列，这个队列将存储字符类型 (<code>Character</code>) 的元素。</li>
<li><code>letters</code>：这是我们为队列定义的变量名。</li>
<li><code>new</code>: 是 Java 的一个关键字，用于创建对象。</li>
<li><code>LinkedList&lt;Character&gt;()</code>: 通过调用 LinkedList 的构造方法来创建一个新的空链表。因为 <code>LinkedList</code> 类在 Java 标准库中实现了 <code>Queue</code> 接口，所以它可以作为队列来使用。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>这行代码创建了一个新的 <code>LinkedList</code> 对象，并将其指定为 <code>Queue</code> 接口的实例。结果是我们得到了一个空的队列，可以用来存储字符。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>当你需要一个队列来存储、添加和删除元素，并且希望具有链表的特性（例如 O(1) 时间复杂度的插入和删除操作）时，这种数据结构是非常有用的。</li>
</ul>
</li>
</ul>
<p>简而言之，这行代码创建了一个队列数据结构，这个队列内部使用链表来存储和管理数据。</p>
<h2 id="解释-int-occurrences-new-int-26"><a href="#解释-int-occurrences-new-int-26" class="headerlink" title="解释 int[] occurrences &#x3D; new int[26];"></a>解释 int[] occurrences &#x3D; new int[26];</h2><p>在这行代码中，我们正在初始化一个整型数组，长度为26。</p>
<ul>
<li><p><strong>组成部分</strong>：</p>
<ul>
<li><code>int[]</code>：表示我们正在声明的是一个整型数组。</li>
<li><code>occurrences</code>：这是我们为数组定义的变量名。</li>
<li><code>new</code>: 是 Java 的一个关键字，用于创建新的数组或对象。</li>
<li><code>int[26]</code>: 表示这个数组的长度是26。</li>
</ul>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>这行代码初始化了一个整型数组，所有元素的值默认为0。这是因为在 Java 中，当你创建一个整型数组，它的所有元素都会默认初始化为0。</li>
</ul>
</li>
<li><p><strong>应用场景</strong>：</p>
<ul>
<li>假设你想跟踪英文字母表中每个字母出现的次数。由于英文字母表中有26个字母，所以这个数组正好可以用来表示每个字母的出现次数。例如，<code>occurrences[0]</code> 可以用来表示字母 ‘A’ 的出现次数，<code>occurrences[1]</code> 可以表示字母 ‘B’ 的出现次数，以此类推。</li>
</ul>
</li>
</ul>
<p>简而言之，这行代码创建了一个长度为26的整型数组，通常用于跟踪英文字母的出现次数。</p>
<h2 id="String-与-Char-的不同"><a href="#String-与-Char-的不同" class="headerlink" title="String 与 Char 的不同"></a>String 与 Char 的不同</h2><h3 id="1-定义："><a href="#1-定义：" class="headerlink" title="1. 定义："></a>1. 定义：</h3><ul>
<li><p><strong>String</strong>:</p>
<ul>
<li><code>String</code> 是 Java 中的一个类，它表示的是字符序列。也就是说，<code>String</code> 可以包含多个字符。</li>
<li>示例：<code>&quot;Hello, World!&quot;</code></li>
</ul>
</li>
<li><p><strong>Char</strong>:</p>
<ul>
<li><code>char</code> 是 Java 中的一个基本数据类型，它表示的是单个字符。</li>
<li>示例：<code>&#39;H&#39;</code></li>
</ul>
</li>
</ul>
<h3 id="2-存储容量："><a href="#2-存储容量：" class="headerlink" title="2. 存储容量："></a>2. 存储容量：</h3><ul>
<li><p><strong>String</strong>:</p>
<ul>
<li>可以存储0个、1个或多个字符。例如，<code>&quot;&quot;</code>、<code>&quot;a&quot;</code> 和 <code>&quot;alphabet&quot;</code> 都是有效的字符串。</li>
</ul>
</li>
<li><p><strong>Char</strong>:</p>
<ul>
<li>只能存储一个字符。例如，<code>&#39;a&#39;</code> 是一个有效的字符，但 <code>&#39;ab&#39;</code> 不是。</li>
</ul>
</li>
</ul>
<h3 id="3-操作："><a href="#3-操作：" class="headerlink" title="3. 操作："></a>3. 操作：</h3><ul>
<li><p><strong>String</strong>:</p>
<ul>
<li>由于是一个类，所以它有很多有用的方法，例如：<code>.length()</code>、<code>.substring()</code>、<code>.replace()</code> 等。</li>
</ul>
</li>
<li><p><strong>Char</strong>:</p>
<ul>
<li>作为基本数据类型，<code>char</code> 没有上述的方法。但你可以执行某些操作，例如字符比较。</li>
</ul>
</li>
</ul>
<h3 id="4-内存消耗："><a href="#4-内存消耗：" class="headerlink" title="4. 内存消耗："></a>4. 内存消耗：</h3><ul>
<li><p><strong>String</strong>:</p>
<ul>
<li>由于它可以存储多个字符，所以通常消耗的内存比 <code>char</code> 要多。</li>
</ul>
</li>
<li><p><strong>Char</strong>:</p>
<ul>
<li>占用的内存通常较少，因为它只存储一个字符。</li>
</ul>
</li>
</ul>
<h3 id="5-使用场景："><a href="#5-使用场景：" class="headerlink" title="5. 使用场景："></a>5. 使用场景：</h3><ul>
<li><p><strong>String</strong>:</p>
<ul>
<li>当你需要处理文字、句子或任何字符序列时，通常会使用 <code>String</code>。</li>
</ul>
</li>
<li><p><strong>Char</strong>:</p>
<ul>
<li>当你需要处理单个字符时，例如，分析用户输入的每个字符，或读取文件时逐个处理字符，你可能会选择使用 <code>char</code>。</li>
</ul>
</li>
</ul>
<p>总之，虽然 <code>String</code> 和 <code>char</code> 都与字符有关，但它们在定义、功能和使用上都有很大的不同。</p>
<h2 id="代码解释-String-inputStr-keyboard-nextLine"><a href="#代码解释-String-inputStr-keyboard-nextLine" class="headerlink" title="代码解释: String inputStr &#x3D; keyboard.nextLine();"></a>代码解释: String inputStr &#x3D; keyboard.nextLine();</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>这行代码的主要作用是从标准输入流（例如键盘）中读取用户输入的一行文本，并将这个文本存储到一个名为 <code>inputStr</code> 的字符串变量中。</p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ol>
<li><strong>keyboard</strong>: 这是一个 <code>Scanner</code> 对象，它提供了从不同输入源（例如标准输入、文件等）读取数据的功能。</li>
<li><strong>nextLine() 方法</strong>: 是 <code>Scanner</code> 类的一个方法，它读取并返回当前输入源的下一行文本。</li>
<li><strong>String inputStr</strong>: 定义了一个字符串变量，用于存储从 <code>keyboard</code> 读取的文本。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设用户输入了 “Hello, World!”，那么 <code>inputStr</code> 会存储 “Hello, World!” 这个字符串。</p>
<p>总之，这行代码让开发者能够简单地从标准输入读取用户的输入，并存储到一个字符串变量中，以便后续处理或使用。</p>
<h2 id="代码解释-字符统计与处理"><a href="#代码解释-字符统计与处理" class="headerlink" title="代码解释: 字符统计与处理"></a>代码解释: 字符统计与处理</h2><p>这段代码主要是用 <code>while</code> 循环来遍历字符串 <code>inputStr</code> 中的每个字符，并统计每个字符出现的次数及其在 <code>occurrences</code> 数组中的位置。 </p>
<h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><ol>
<li><p><strong>初始化</strong>:</p>
<ul>
<li>循环变量 <code>i</code> 的初始值为 0，它用于从字符串的起始位置开始遍历。</li>
<li><code>thisChar</code> 用于暂存当前字符。</li>
<li><code>arrayPos</code> 用于计算并存放当前字符在 <code>occurrences</code> 数组中的位置。</li>
</ul>
</li>
<li><p><strong>获取当前字符</strong>:</p>
<ul>
<li>使用 <code>charAt()</code> 方法，获取 <code>inputStr</code> 字符串中第 <code>i</code> 个字符，并存储在 <code>thisChar</code> 变量中。</li>
</ul>
</li>
<li><p><strong>计算字符位置</strong>:</p>
<ul>
<li>当前字符在 <code>occurrences</code> 数组中的位置可以通过 <code>(int)thisChar - (int)&#39;a&#39;</code> 计算得出。这样做的前提是字符串中的字符都是小写字母。</li>
</ul>
</li>
<li><p><strong>更新统计数组</strong>:</p>
<ul>
<li>用 <code>arrayPos</code> 作为索引，在 <code>occurrences</code> 数组的相应位置上，增加字符出现的次数。</li>
</ul>
</li>
<li><p><strong>处理字符</strong>:</p>
<ul>
<li>将 <code>thisChar</code> 添加到 <code>letters</code> 队列中。</li>
</ul>
</li>
<li><p><strong>打印信息</strong>:</p>
<ul>
<li>使用 <code>printf()</code> 方法打印字符及其在 <code>occurrences</code> 数组中的位置。</li>
</ul>
</li>
<li><p><strong>循环控制</strong>:</p>
<ul>
<li>每次循环结束后，<code>i</code> 自增，以遍历下一个字符，直到整个字符串被遍历完毕。</li>
</ul>
</li>
<li><p><strong>结束循环后的操作</strong>:</p>
<ul>
<li>循环结束后，布尔变量 <code>finished</code> 被设置为 <code>false</code>。这可能为后续代码预留了一个状态标识。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段代码通过 <code>while</code> 循环精确地遍历和处理字符串中的每个字符，并根据其ASCII值来更新字符出现的次数统计。此外，它还将每个字符添加到队列中，并提供有关字符在统计数组中位置的实时反馈。</p>
<h1 id="数据结构的不同"><a href="#数据结构的不同" class="headerlink" title="数据结构的不同"></a>数据结构的不同</h1><p>数据结构是在计算机中组织和存储数据的方式，它使得数据可以高效地访问和修改。不同的数据结构在不同的应用场景中有其独特的优势和特点。</p>
<h2 id="1-数组-Array"><a href="#1-数组-Array" class="headerlink" title="1. 数组 (Array)"></a>1. 数组 (Array)</h2><ul>
<li><strong>定义</strong>: 一个固定大小的数据元素集合，这些数据元素在内存中是连续的。</li>
<li><strong>优点</strong>:<ul>
<li>O(1) 时间复杂度访问任意元素。</li>
<li>数据在内存中是连续的，有利于CPU缓存。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>大小固定，不能动态增长。</li>
<li>插入和删除元素，尤其是在中间位置，可能需要移动大量元素。</li>
</ul>
</li>
</ul>
<h2 id="2-链表-Linked-List"><a href="#2-链表-Linked-List" class="headerlink" title="2. 链表 (Linked List)"></a>2. 链表 (Linked List)</h2><ul>
<li><strong>定义</strong>: 由一系列节点组成，每个节点包含一个值和指向下一个节点的指针。</li>
<li><strong>优点</strong>:<ul>
<li>动态大小，能够根据需要增长或缩小。</li>
<li>在已知节点的情况下，插入和删除操作可以达到 O(1) 的时间复杂度。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>访问特定索引的元素可能需要从头开始遍历，最坏情况下时间复杂度为 O(n)。</li>
<li>需要额外的空间存储指针。</li>
</ul>
</li>
</ul>
<h2 id="3-栈-Stack"><a href="#3-栈-Stack" class="headerlink" title="3. 栈 (Stack)"></a>3. 栈 (Stack)</h2><ul>
<li><strong>定义</strong>: 一个后进先出 (LIFO) 的数据结构。</li>
<li><strong>优点</strong>:<ul>
<li>提供快速的插入和删除操作。</li>
<li>用于执行历史、撤销操作、函数调用等。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>通常只能访问顶部元素。</li>
<li>如果不使用动态数组，可能会有大小限制。</li>
</ul>
</li>
</ul>
<h2 id="4-队列-Queue"><a href="#4-队列-Queue" class="headerlink" title="4. 队列 (Queue)"></a>4. 队列 (Queue)</h2><ul>
<li><strong>定义</strong>: 一个先进先出 (FIFO) 的数据结构。</li>
<li><strong>优点</strong>:<ul>
<li>适合用于数据的有序处理，如任务调度。</li>
<li>插入和删除操作通常很快。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>和栈一样，通常只能访问前端元素。</li>
<li>如果不使用动态数组或链表，可能会有大小限制。</li>
</ul>
</li>
</ul>
<h2 id="5-哈希表-Hash-Table"><a href="#5-哈希表-Hash-Table" class="headerlink" title="5. 哈希表 (Hash Table)"></a>5. 哈希表 (Hash Table)</h2><ul>
<li><strong>定义</strong>: 使用哈希函数将键映射到数组的索引中的数据结构。</li>
<li><strong>优点</strong>:<ul>
<li>如果哈希函数良好，许多操作都可以在平均时间复杂度 O(1) 下完成。</li>
<li>适用于快速数据检索和查找操作。</li>
</ul>
</li>
<li><strong>缺点</strong>:<ul>
<li>依赖于哈希函数的效率。</li>
<li>可能出现碰撞，即多个键映射到同一个索引。</li>
</ul>
</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>选择适当的数据结构取决于特定的需求和场景。每种数据结构都有其优点和缺点，因此在设计和实现算法时，了解各种数据结构的特性是非常重要的。</p>
<h1 id="Stacks-java"><a href="#Stacks-java" class="headerlink" title="Stacks.java"></a>Stacks.java</h1><h2 id="String-reverseStr-“”"><a href="#String-reverseStr-“”" class="headerlink" title="String reverseStr &#x3D; “”;"></a>String reverseStr &#x3D; “”;</h2><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>在Java中，<code>String reverseStr = &quot;&quot;;</code> 是一条声明并初始化一个名为 <code>reverseStr</code> 的字符串变量的语句。</p>
<p><strong>组成部分</strong>:</p>
<ul>
<li><strong>String</strong>: 声明变量的类型是字符串。</li>
<li><strong>reverseStr</strong>: 是变量的名称。</li>
<li><strong>“”</strong>: 是变量的初始值，代表一个空字符串。</li>
</ul>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>此语句的主要目的是为进一步操作（如字符串的反转或其他字符串操作）提供一个初始的空字符串。在程序中，可能会根据特定的逻辑和需求，逐步将字符或其他字符串追加到 <code>reverseStr</code> 中。</p>
<h2 id="while-i-inputStr-length-charStack-push-inputStr-charAt-i-i"><a href="#while-i-inputStr-length-charStack-push-inputStr-charAt-i-i" class="headerlink" title="while (i &lt; inputStr.length())&#x2F;charStack.push(inputStr.charAt(i))&#x2F;i++;"></a>while (i &lt; inputStr.length())&#x2F;charStack.push(inputStr.charAt(i))&#x2F;i++;</h2><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><p>这段代码使用 <code>while</code> 循环，目的是遍历字符串 <code>inputStr</code> 中的每个字符，并将它们依次压入一个栈中。</p>
<p><strong>核心操作</strong>:</p>
<ul>
<li><strong>charAt()</strong>: 从字符串中获取指定位置的字符。</li>
<li><strong>push()</strong>: 用于将字符压入栈中。</li>
</ul>
<h3 id="详细步骤-1"><a href="#详细步骤-1" class="headerlink" title="详细步骤:"></a>详细步骤:</h3><ol>
<li><strong>初始化</strong>: 循环变量 <code>i</code> 的初始值通常为0，表示从字符串的第一个字符开始。</li>
<li><strong>判断条件</strong>: <code>i &lt; inputStr.length()</code> 确保只要还没有遍历完整个字符串，循环就会继续执行。</li>
<li><strong>操作</strong>: 在循环体中，使用 <code>inputStr.charAt(i)</code> 获取第 <code>i</code> 个字符，并使用 <code>charStack.push()</code> 将其压入栈中。</li>
<li><strong>递增</strong>: <code>i++</code> 使得 <code>i</code> 的值在每次循环结束后都增加1，为下一次循环准备。</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>如果 <code>inputStr</code> 的值为 “hello”，循环将会执行5次，将 ‘h’, ‘e’, ‘l’, ‘l’, 和 ‘o’ 这五个字符依次压入栈中。</p>
<h2 id="while-charStack-empty"><a href="#while-charStack-empty" class="headerlink" title="while (!charStack.empty())"></a>while (!charStack.empty())</h2><h3 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h3><p>这段代码使用 <code>while</code> 循环，目的是从栈 <code>charStack</code> 中依次弹出字符，并将这些字符拼接成新的字符串 <code>reverseStr</code>。</p>
<p><strong>核心操作</strong>:</p>
<ul>
<li><strong>empty()</strong>: 判断栈是否为空。</li>
<li><strong>pop()</strong>: 从栈顶弹出一个元素。</li>
</ul>
<h3 id="详细步骤-2"><a href="#详细步骤-2" class="headerlink" title="详细步骤:"></a>详细步骤:</h3><ol>
<li><strong>判断条件</strong>: <code>!charStack.empty()</code> 确保只要栈中还有元素，循环就会继续执行。</li>
<li><strong>操作</strong>: 在循环体中，使用 <code>charStack.pop()</code> 从栈顶弹出一个字符，并使用 <code>+=</code> 运算符将其拼接到 <code>reverseStr</code> 的末尾。</li>
<li><strong>结束条件</strong>: 当栈为空时，循环自动结束。</li>
</ol>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>假设栈中从底到顶依次存放了字符 ‘h’, ‘e’, ‘l’, ‘l’, 和 ‘o’，那么这个循环将会执行5次，从栈中依次弹出字符 ‘o’, ‘l’, ‘l’, ‘e’, 和 ‘h’，并拼接得到新的字符串 “olleh”。</p>
<h2 id="System-out-printf-“-s-resersed-is-s-n”-inputStr-reverseStr"><a href="#System-out-printf-“-s-resersed-is-s-n”-inputStr-reverseStr" class="headerlink" title="System.out.printf(“%s resersed is %s\n”, inputStr, reverseStr);"></a>System.out.printf(“%s resersed is %s\n”, inputStr, reverseStr);</h2><h3 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h3><p>这段代码使用 <code>System.out.printf()</code> 方法，目的是格式化输出原始字符串 <code>inputStr</code> 及其反转后的字符串 <code>reverseStr</code>。</p>
<p><strong>核心操作</strong>:</p>
<ul>
<li><strong>printf()</strong>: Java中的格式化输出函数。</li>
<li><strong>%s</strong>: 用于替代字符串参数。</li>
</ul>
<h3 id="详细步骤-3"><a href="#详细步骤-3" class="headerlink" title="详细步骤:"></a>详细步骤:</h3><ol>
<li><strong>格式字符串</strong>: <code>&quot;%s reversed is %s\n&quot;</code>。其中，两个 <code>%s</code> 分别是占位符，表示将被字符串变量的值替代。</li>
<li><strong>参数传递</strong>: <code>inputStr</code> 和 <code>reverseStr</code> 分别提供了要插入到格式化字符串中的值。</li>
<li><strong>输出结果</strong>: 根据提供的参数和格式字符串，将组合后的字符串输出到控制台。</li>
</ol>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>假设 <code>inputStr</code> 的值为 “hello” 而 <code>reverseStr</code> 的值为 “olleh”，那么执行此代码将在控制台输出:</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">Jacka10086</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/10/28/Week5-pratical/">http://example.com/2023/10/28/Week5-pratical/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/practical/">practical</a><a class="post-meta__tags" href="/tags/Week5/">Week5</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2023/10/18/fq6OmvaUIxkbdo5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/29/T4/" title="T4"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">T4</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/28/Week5-challenge/" title="Week5-Challenge"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Week5-Challenge</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/10/17/Week4%20pratical/" title="Week4-pratical"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-17</div><div class="title">Week4-pratical</div></div></a></div><div><a href="/2023/10/03/week3-pratical/" title="week3-pratical"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-03</div><div class="title">week3-pratical</div></div></a></div><div><a href="/2023/09/26/Week1-practical/" title="Week1-practical"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-26</div><div class="title">Week1-practical</div></div></a></div><div><a href="/2023/09/25/week2-practical/" title="week2-practical"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-25</div><div class="title">week2-practical</div></div></a></div><div><a href="/2023/11/15/Lab5/" title="LAB5"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-15</div><div class="title">LAB5</div></div></a></div><div><a href="/2023/10/29/T5/" title="T5"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-29</div><div class="title">T5</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2023/10/18/fq6OmvaUIxkbdo5.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Jacka10086</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">112</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Jacka10086"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Card-java"><span class="toc-number">1.</span> <span class="toc-text">Card.java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-Card-ranks-length"><span class="toc-number">1.1.</span> <span class="toc-text">解释 Card.ranks.length</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-nextInt"><span class="toc-number">1.2.</span> <span class="toc-text">解释 nextInt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-this-rank-rank"><span class="toc-number">1.3.</span> <span class="toc-text">解释 this.rank &#x3D; rank;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-public-String-getRank-return-Card-ranks-this-rank"><span class="toc-number">1.3.1.</span> <span class="toc-text">解释 public String getRank() { return Card.ranks[this.rank]; }</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-public-boolean-isBiggerThan-Card-otherCard-return-this-rank-otherCard-rank"><span class="toc-number">1.4.</span> <span class="toc-text">解释 public boolean isBiggerThan(Card otherCard) { return this.rank &gt; otherCard.rank; }</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CardTest-java"><span class="toc-number">2.</span> <span class="toc-text">CardTest.java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-Deck-deck-new-Deck"><span class="toc-number">2.1.</span> <span class="toc-text">解释 Deck deck &#x3D; new Deck();</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-System-out-println-deck-deal"><span class="toc-number">2.2.</span> <span class="toc-text">解释 System.out.println(deck.deal());</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Deck-java"><span class="toc-number">3.</span> <span class="toc-text">Deck.java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-System-out-println-deck-deal-1"><span class="toc-number">3.1.</span> <span class="toc-text">解释 System.out.println(deck.deal());</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-this-deck-add-new-Card-i-13-i-13"><span class="toc-number">3.2.</span> <span class="toc-text">解释 this.deck.add(new Card(i % 13, i &#x2F; 13));</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-if-this-deck-size-0-%E2%80%A6"><span class="toc-number">3.3.</span> <span class="toc-text">解释 if (this.deck.size() &gt; 0) { … }</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-public-String-toString-%E2%80%A6"><span class="toc-number">3.4.</span> <span class="toc-text">解释 public String toString() { … }</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-for-Card-card-this-deck"><span class="toc-number">3.5.</span> <span class="toc-text">解释 for (Card card : this.deck)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-public-static-void-main-String-args"><span class="toc-number">3.6.</span> <span class="toc-text">解释 public static void main(String[] args)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-Scanner-keyboard-new-Scanner-System-in"><span class="toc-number">3.7.</span> <span class="toc-text">解释 Scanner keyboard &#x3D; new Scanner(System.in);</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-Queue-letters-new-LinkedList"><span class="toc-number">3.8.</span> <span class="toc-text">解释 Queue letters &#x3D; new LinkedList();</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-int-occurrences-new-int-26"><span class="toc-number">3.9.</span> <span class="toc-text">解释 int[] occurrences &#x3D; new int[26];</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E4%B8%8E-Char-%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">3.10.</span> <span class="toc-text">String 与 Char 的不同</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">3.10.1.</span> <span class="toc-text">1. 定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F%EF%BC%9A"><span class="toc-number">3.10.2.</span> <span class="toc-text">2. 存储容量：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">3.10.3.</span> <span class="toc-text">3. 操作：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97%EF%BC%9A"><span class="toc-number">3.10.4.</span> <span class="toc-text">4. 内存消耗：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">3.10.5.</span> <span class="toc-text">5. 使用场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-String-inputStr-keyboard-nextLine"><span class="toc-number">3.11.</span> <span class="toc-text">代码解释: String inputStr &#x3D; keyboard.nextLine();</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">3.11.1.</span> <span class="toc-text">功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">3.11.2.</span> <span class="toc-text">细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.11.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-%E5%AD%97%E7%AC%A6%E7%BB%9F%E8%AE%A1%E4%B8%8E%E5%A4%84%E7%90%86"><span class="toc-number">3.12.</span> <span class="toc-text">代码解释: 字符统计与处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.12.1.</span> <span class="toc-text">详细步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.12.2.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">4.</span> <span class="toc-text">数据结构的不同</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84-Array"><span class="toc-number">4.1.</span> <span class="toc-text">1. 数组 (Array)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%93%BE%E8%A1%A8-Linked-List"><span class="toc-number">4.2.</span> <span class="toc-text">2. 链表 (Linked List)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%88-Stack"><span class="toc-number">4.3.</span> <span class="toc-text">3. 栈 (Stack)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%98%9F%E5%88%97-Queue"><span class="toc-number">4.4.</span> <span class="toc-text">4. 队列 (Queue)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%93%88%E5%B8%8C%E8%A1%A8-Hash-Table"><span class="toc-number">4.5.</span> <span class="toc-text">5. 哈希表 (Hash Table)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stacks-java"><span class="toc-number">5.</span> <span class="toc-text">Stacks.java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String-reverseStr-%E2%80%9C%E2%80%9D"><span class="toc-number">5.1.</span> <span class="toc-text">String reverseStr &#x3D; “”;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">5.2.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">5.3.</span> <span class="toc-text">用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while-i-inputStr-length-charStack-push-inputStr-charAt-i-i"><span class="toc-number">5.4.</span> <span class="toc-text">while (i &lt; inputStr.length())&#x2F;charStack.push(inputStr.charAt(i))&#x2F;i++;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-number">5.4.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">5.4.2.</span> <span class="toc-text">详细步骤:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#while-charStack-empty"><span class="toc-number">5.5.</span> <span class="toc-text">while (!charStack.empty())</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-2"><span class="toc-number">5.5.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">5.5.2.</span> <span class="toc-text">详细步骤:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-out-printf-%E2%80%9C-s-resersed-is-s-n%E2%80%9D-inputStr-reverseStr"><span class="toc-number">5.6.</span> <span class="toc-text">System.out.printf(“%s resersed is %s\n”, inputStr, reverseStr);</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-3"><span class="toc-number">5.6.1.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4-3"><span class="toc-number">5.6.2.</span> <span class="toc-text">详细步骤:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">5.6.2.1.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/26/301%E7%AC%AC%E4%BA%94%E5%91%A8LEC/" title="301第五周LEC">301第五周LEC</a><time datetime="2024-02-26T16:37:58.000Z" title="Created 2024-02-26 16:37:58">2024-02-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/23/301%E7%AC%AC%E5%9B%9B%E5%91%A8Lab7/" title="301第四周Lab7">301第四周Lab7</a><time datetime="2024-02-23T16:17:37.000Z" title="Created 2024-02-23 16:17:37">2024-02-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/23/301%E7%AC%AC%E5%9B%9B%E5%91%A8TUL/" title="301第四周TUL">301第四周TUL</a><time datetime="2024-02-23T15:49:54.000Z" title="Created 2024-02-23 15:49:54">2024-02-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/19/301%E7%AC%AC%E5%9B%9B%E5%91%A8LEC/" title="301第四周LEC">301第四周LEC</a><time datetime="2024-02-19T21:43:03.000Z" title="Created 2024-02-19 21:43:03">2024-02-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/14/431%E7%AC%AC%E4%B8%89%E5%91%A8LEC/" title="431第三周LEC">431第三周LEC</a><time datetime="2024-02-14T21:42:49.000Z" title="Created 2024-02-14 21:42:49">2024-02-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Jacka10086</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>